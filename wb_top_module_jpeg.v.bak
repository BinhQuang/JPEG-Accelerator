module wb_top_module_jpeg (
    // Wishbone interface
    input  wire        wb_clk_i,    // Wishbone clock
    input  wire        wb_rst_i,    // Wishbone reset (active-high)
    input  wire [31:0] wb_adr_i,    // Address input
    input  wire [31:0] wb_dat_i,    // Data input
    output reg  [31:0] wb_dat_o,    // Data output
    input  wire        wb_we_i,     // Write enable
    input  wire        wb_stb_i,    // Strobe
    input  wire        wb_cyc_i,    // Cycle
    output reg         wb_ack_o     // Acknowledge
);

    // Internal signals for top_module_jpeg
    wire        clk;
    wire        rst_n;
    wire        start;
    wire [7:0]  R, G, B;
    wire [15:0] out_code;
    wire [3:0]  out_len;
    wire        out_valid;
    wire        img_done;

    // Registers
    reg         start_reg;
    reg [7:0]   R_reg, G_reg, B_reg;
    reg         busy;
    reg [15:0]  code_reg;
    reg [3:0]   len_reg;
    reg         valid_reg;

    // Address decoding
    localparam ADDR_CONTROL       = 32'h00;
    localparam ADDR_STATUS        = 32'h04;
    localparam ADDR_RGB_INPUT     = 32'h08;
    localparam ADDR_ENCODED_OUTPUT = 32'h0C;

    // Connect Wishbone clock and reset
    assign clk = wb_clk_i;
    assign rst_n = ~wb_rst_i; // Convert active-high to active-low

    // Instantiate top_module_jpeg
    top_module_jpeg #(
        .IMG_WIDTH(64),
        .IMG_HEIGHT(64)
    ) jpeg_inst (
        .clk(clk),
        .rst_n(rst_n),
        .start(start_reg),
        .R(R_reg),
        .G(G_reg),
        .B(B_reg),
        .out_code(out_code),
        .out_len(out_len),
        .out_valid(out_valid),
        .img_done(img_done)
    );

    // Busy signal logic
    always @(posedge wb_clk_i or posedge wb_rst_i) begin
        if (wb_rst_i) begin
            busy <= 1'b0;
        end else begin
            if (start_reg && !img_done)
                busy <= 1'b1;
            else if (img_done)
                busy <= 1'b0;
        end
    end

    // Wishbone interface logic
    always @(posedge wb_clk_i or posedge wb_rst_i) begin
        if (wb_rst_i) begin
            wb_ack_o <= 1'b0;
            wb_dat_o <= 32'd0;
            start_reg <= 1'b0;
            R_reg <= 8'd0;
            G_reg <= 8'd0;
            B_reg <= 8'd0;
            code_reg <= 16'd0;
            len_reg <= 4'd0;
            valid_reg <= 1'b0;
        end else begin
            wb_ack_o <= 1'b0;
            wb_dat_o <= 32'd0;

            // Handle valid output from JPEG module
            if (out_valid) begin
                code_reg <= out_code;
                len_reg <= out_len;
                valid_reg <= 1'b1;
            end else if (img_done) begin
                valid_reg <= 1'b0;
            end

            // Wishbone transaction
            if (wb_cyc_i && wb_stb_i) begin
                wb_ack_o <= 1'b1; // Acknowledge transaction
                if (wb_we_i) begin // Write operations
                    case (wb_adr_i)
                        ADDR_CONTROL: begin
                            start_reg <= wb_dat_i[0];
                        end
                        ADDR_RGB_INPUT: begin
                            R_reg <= wb_dat_i[31:24];
                            G_reg <= wb_dat_i[23:16];
                            B_reg <= wb_dat_i[15:8];
                        end
                        default: begin
                            // Ignore invalid addresses
                        end
                    endcase
                end else begin // Read operations
                    case (wb_adr_i)
                        ADDR_CONTROL: begin
                            wb_dat_o <= {31'd0, start_reg};
                        end
                        ADDR_STATUS: begin
                            wb_dat_o <= {30'd0, busy, img_done};
                        end
                        ADDR_ENCODED_OUTPUT: begin
                            wb_dat_o <= {code_reg, 12'd0, len_reg};
                        end
                        default: begin
                            wb_dat_o <= 32'd0;
                        end
                    endcase
                end
            end
        end
    end

endmodule