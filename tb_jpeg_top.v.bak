`timescale 1ns/1ps

module tb_jpeg_top;

    // Khai báo tín hiệu
    reg clk;
    reg rst_n;
    reg start;
    reg [7:0] R, G, B;
    reg pixel_valid;

    wire signed [15:0] dct_Y, dct_Cb, dct_Cr;
    wire done;

    // Clock tạo xung 10ns
    initial clk = 0;
    always #5 clk = ~clk;

    // Instantiate jpeg_top
    jpeg_topfour uut (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        .R(R),
        .G(G),
        .B(B),
        .pixel_valid(pixel_valid),
        .dct_Y(dct_Y),
        .dct_Cb(dct_Cb),
        .dct_Cr(dct_Cr),
        .done(done)
    );

    // Nạp ảnh giả lập - ảnh 16x16 = 256 pixel
    // Ở đây dùng giá trị RGB đơn giản cho dễ debug
    integer i;
    reg [7:0] img_R[0:255];
    reg [7:0] img_G[0:255];
    reg [7:0] img_B[0:255];

    initial begin
        // Reset ban đầu
        rst_n = 0;
        start = 0;
        pixel_valid = 0;
        R = 0;
        G = 0;
        B = 0;
        #20;
        rst_n = 1;

        // Khởi tạo dữ liệu ảnh giả lập (grayscale từ 0 đến 255)
        for (i = 0; i < 256; i = i + 1) begin
            img_R[i] = i[7:0];
            img_G[i] = i[7:0];
            img_B[i] = i[7:0];
        end

        @(posedge clk);
        start = 1;
        @(posedge clk);
        start = 0;

        // Gửi từng pixel vào
        for (i = 0; i < 256; i = i + 1) begin
            @(posedge clk);
            R <= img_R[i];
            G <= img_G[i];
            B <= img_B[i];
            pixel_valid <= 1;
        end

        // Kết thúc gửi pixel
        @(posedge clk);
        pixel_valid <= 0;

        // Chờ tín hiệu hoàn tất toàn bộ pipeline
        wait(done);

        $display("DCT hoàn tất!");
        $finish;
    end

endmodule
